# 浏览量统计与防刷技术实现

## 一、 功能概述

在博客系统中，文章阅读量（Views）是一个重要的指标。为了保证数据的真实性和防止恶意刷量，系统实现了一套基于 **内存限流 (In-Memory Rate Limiting)** 的防刷机制。

## 二、 技术方案

### 1. 核心原理

利用服务端的内存（Variable/Map）记录最近的访问行为，通过 "IP + 文章ID" 作为唯一键，设定一个 **时间窗口 (Time Window)**。在此窗口内的重复请求将被拦截，不进行数据库更新。

### 2. 详细设计

- **数据结构**: 使用 `Map<string, number>` 存储访问记录。
  - **Key**: `${IP}:${PostID}` (例如 `127.0.0.1:42`)
  - **Value**: 上次有效访问的时间戳 (Timestamp)
- **时间窗口**: 30 秒 (`RESTRICTION_WINDOW_MS`)
- **清理机制**: 每 1 小时 (`CLEANUP_INTERVAL_MS`) 遍历 Map，移除过期记录，防止内存泄漏。

### 3. 处理流程

1.  **请求接收**: 用户访问文章详情页，前端调用 `POST /api/posts/:id/view` 接口。
2.  **IP 提取**: 控制器从请求上下文 (Context) 中获取客户端真实 IP。
3.  **防刷校验** (Service 层):
    - 生成 Key: `ip:postId`。
    - 检查 Map 中是否存在该 Key。
    - 若存在且 `(当前时间 - 记录时间) < 30秒` -> **拦截**，返回 `false`。
    - 若不存在或已过期 -> **通过**。
4.  **数据更新**:
    - 更新 Map 中该 Key 的时间戳为当前时间。
    - 原子更新数据库: `prisma.post.update({ views: { increment: 1 } })`。
5.  **返回结果**: 返回 `{ success: true, increased: boolean }`。

## 三、 代码片段 (TypeScript)

实现逻辑位于 `post.service.ts` 中：

```typescript
// 浏览记录缓存：Key = "ip:postId", Value = 时间戳
const recentViews = new Map<string, number>();
const RESTRICTION_WINDOW_MS = 30 * 1000; // 30s
const CLEANUP_INTERVAL_MS = 60 * 60 * 1000; // 1h

// 定时清理
setInterval(() => {
  const now = Date.now();
  for (const [key, timestamp] of recentViews.entries()) {
    if (now - timestamp > RESTRICTION_WINDOW_MS) {
      recentViews.delete(key);
    }
  }
}, CLEANUP_INTERVAL_MS);

// 核心方法
async incrementView(postId: number, ip: string): Promise<boolean> {
  const key = `${ip}:${postId}`;
  const now = Date.now();
  const lastViewTime = recentViews.get(key);

  // 1. 检查是否在限制窗口内
  if (lastViewTime && now - lastViewTime < RESTRICTION_WINDOW_MS) {
    return false; // 最近已访问，触发防刷拦截
  }

  // 2. 记录本次访问
  recentViews.set(key, now);

  // 3. 更新数据库
  try {
    await prisma.post.update({
      where: { id: postId },
      data: { views: { increment: 1 } },
    });
    return true;
  } catch (error) {
    return false;
  }
}
```

## 四、 优缺点分析

- **优点**:
  - 实现简单，无需引入 Redis 等外部组件。
  - 性能极高，纯内存操作。
  - 对大多数小型至中型博客系统足够有效。
- **缺点**:
  - 应用重启后记录丢失（但对浏览量几秒的误差可忽略）。
  - 多进程部署（Cluster/PM2）时，内存无法共享，防刷限制各自独立（30s 内可能被刷 N 次，N=进程数）。若需要严格一致性，建议升级为 Redis 共享存储。
