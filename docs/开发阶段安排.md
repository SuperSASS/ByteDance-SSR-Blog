# 开发阶段安排

1. 阶段 0：项目整体脚手架 & Monorepo 搭好
2. 阶段 1：最小 SSR SPA 骨架（只有“Hello SSR + Router”）
3. 阶段 2：数据库 & Prisma & 基础数据模型（SQLite 起步）
4. 阶段 3：后端 API 分层（Controller/Service/Router）
5. 阶段 4：前台页面骨架（Home / Detail / Tag / Layout）
6. 阶段 5：SSR 与 React Router 全链路打通（真正的 SSR SPA）
7. 阶段 6：后台登录 & JWT 鉴权 & 权限模型
8. 阶段 7：后台文章管理 + Markdown 编辑器（react-md-editor）
9. 阶段 8：前台体验完善（Markdown 渲染、标签筛选、分页、主题切换）
10. 阶段 9：安全与工程化完善（XSS、防错、日志、跨域、限流占位等）
11. 阶段 10：进阶与可选增强（MySQL、Milkdown、评论、导出、Redis 等）

## 阶段 0：项目脚手架 & Monorepo 初始化

### 目标

- 确立 Monorepo 结构 + 前后端基础工程
- 建好基础开发规范（Lint / 格式化 / 提交规范 / Hook）
- 一条命令同时启动前端和后端开发环境
- 约定未来目录组织规范（前、后端分层）
- git 仓库初始化
- 前端目标技术栈锁定为：**React 19 + React Router 7** + Vite + TypeScript

### 目录结构约定（先约规范，部分目录可以先空着）

**仓库根：**

```txt
.
├─ apps
│  ├─ web        # 前端 SSR SPA（React 19 + React Router 7 + Vite）
│  └─ server     # Koa 后端（tsx）
├─ packages
│  └─ shared     # DTO / 公共类型 / 公共工具
├─ prisma        # Prisma schema / migrations
├─ .husky        # Git hooks（后续生成）
├─ .eslintrc.cjs
├─ .prettierrc
├─ commitlint.config.cjs
└─ package.json
```

**前端 `apps/web/src`：**

```txt
src
├─ app/            # 应用级入口（AppShell 等）
├─ routes/         # routes.tsx 等路由配置（React Router 7 Data Router）
├─ layouts/        # 布局组件（SiteLayout、AdminLayout）
├─ pages/          # 页面组件（HomePage、PostDetailPage 等）
├─ components/     # 复用 UI 组件（Card、PostCard、TagChip 等）
├─ hooks/          # 自定义 hooks（useTheme、useSSRInitialData 等）
├─ stores/         # 将来状态管理（如果用 zustand/mobx 可以放这里）
├─ utils/          # 工具函数（日期格式化、请求封装等）
├─ services/       # 前端 API 封装（fetch/React Query）
├─ styles/         # 全局样式 / Tailwind 扩展
├─ assets/         # 静态资源（图片、SVG）
└─ types/          # 前端专用类型（非共享 DTO）
```

**后端 `apps/server/src`：**

```txt
src
├─ app.ts          # Koa 启动入口（挂中间件和路由）
├─ config/         # 配置加载（env、常量等）
├─ routes/         # 路由组合层（api.ts、ssr.ts 等）
├─ controllers/    # 控制器（post.api.controller.ts、auth.controller.ts）
├─ services/       # 业务逻辑（post.service.ts、user.service.ts）
├─ repositories/   # 数据访问封装（可选，包一层 Prisma 调用）
├─ db/             # PrismaClient 封装、连接管理
├─ middleware/     # 中间件（auth、logger、error-handler、rbac 等）
├─ utils/          # 工具函数（密码哈希、token 工具等）
├─ types/          # 后端专用类型（上下文扩展等）
└─ logs/           # 日志输出目录（生产）
```

> 约束：所有 API/controller 只能放在 `controllers/`，不要堆在 `app.ts` 里。
> `app.ts` 只负责：初始化 Koa、注册中间件、挂载总路由。

### 工具与规范

1. **Lint & 格式化**

- `eslint` + `@typescript-eslint` + `eslint-plugin-react` + `eslint-plugin-react-hooks`
- `prettier` + `eslint-config-prettier`（避免冲突）
- 规则风格：
  - TS：尽量避免 `any`，统一 import 顺序
  - React：函数组件 + Hooks 规则
  - 禁用未使用变量、console.log（生产可改为 warning）

2. **提交规范**

- `commitlint` + `@commitlint/config-conventional`
- `husky`：注册 Git hooks
- `lint-staged`：只对暂存文件跑 lint / prettier

典型配置：

- `.husky/pre-commit`：`pnpm lint-staged`
- `.husky/commit-msg`：`pnpm commitlint --edit $1`

`lint-staged` 例如：

```json
{
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write"],
    "*.{json,md,css}": ["prettier --write"]
  }
}
```

3. **环境变量**

- `dotenv`：在 `apps/server/src/app.ts` 顶部 `import 'dotenv/config';`
- `.env` 中放：`PORT、DATABASE_URL、JWT_SECRET` 等

4. **一键启动命令**

根 `package.json`：

```json
{
  "scripts": {
    "dev": "pnpm -r --parallel dev",
    "dev:web": "pnpm --filter web dev",
    "dev:server": "pnpm --filter server dev",
    "build": "pnpm -r build",
    "lint": "pnpm -r lint"
  }
}
```

> 约定：
>
> - `apps/web` 暴露 `dev/build/lint` 等脚本
> - `apps/server` 也暴露 `dev/build/lint` 等脚本
> - 根的 `dev`/`build` 只做聚合，不额外加逻辑。

### 阶段效果

- `pnpm dev` 能同时起 Vite + Koa
- 提交前自动跑 lint & prettier，不规范的代码无法提交
- 项目已有清晰的前后端目录“骨架”，后面各阶段直接按规范往里填东西

---

## 阶段 1：最小 SSR SPA 骨架

### 目标

- 实现最基础的 SSR：访问 `/`，由 Koa 调用 React SSR 返回 HTML（`GET /` → Koa → React SSR → HTML）
- 前后端路由结构成型：
  - `/assets/*` → 静态资源
  - `/api/*` → JSON API（先空）
  - 其它 → SSR

- React Router 前后端同步：服务端 `createMemoryRouter`，客户端 `createBrowserRouter`（基于 React Router 7 Data Router）

此阶段只做最小骨架，不引入 loader/action、use() 等高级特性，后面阶段 5 再升级。

### 关键技术

- React 19 SSR：基于 react-dom/server
  - 初期可以先用 renderToString 保证简单
  - 将来可以升级为 renderToPipeableStream 或 react-dom/static 的新 SSR API
- React Router 7 Data Router：
  - createBrowserRouter / createMemoryRouter / <RouterProvider>
  - 此阶段仅用于“同步前后端路由结构”，暂不启用 loader/action
- Vite dev server 提供 client 入口（开发），后续再分离 server/client bundle

### 放置位置

- `apps/web/src/routes/index.tsx`：路由配置
- `apps/web/src/app/AppShell.tsx`：应用壳
- `apps/web/src/entry-client.tsx`
- `apps/web/src/entry-server.tsx`
- `apps/server/src/routes/ssr.ts`：SSR 路由
- `apps/server/src/app.ts`：Koa 入口

### 约束规范

- 所有路由相关文件放在 `web/src/routes`（前端） / `server/src/routes`（后端）
- `ssr.ts` 专职“页面 SSR”，不含任何 API 逻辑

### 具体工作

1. 在 `apps/web/src` 新建：

- `routes.tsx`：定义最简单路由（可以先用对象数组形式，为后面 Data Router 做准备）

```tsx
export const routes = [
  { path: '/', element: <div>Home SSR</div> },
  { path: '/about', element: <div>About SSR</div> },
];
```

- `AppShell.tsx`：包裹 Router 的壳（后续可加 ThemeProvider、AuthProvider 等）

```tsx
import React from 'react';
import { RouterProvider } from 'react-router-dom';
import type { Router } from 'react-router-dom';

interface AppShellProps {
  router: Router;
  initialData?: any;
}

export const InitialDataContext = React.createContext<any | null>(null);

export function AppShell({ router, initialData }: AppShellProps) {
  return (
    <InitialDataContext.Provider value={initialData ?? null}>
      <RouterProvider router={router} />
    </InitialDataContext.Provider>
  );
}
```

当前的 InitialDataContext 是一个手工的“数据注水”通道，阶段 5 介绍如何用 React Router 7 的 loader + React 19 的 use() / useLoaderData() 来替代手写 **INITIAL_DATA**。

- `entry-client.tsx`：

```tsx
import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import { createBrowserRouter } from 'react-router-dom';
import { routes } from './routes';
import { AppShell } from './AppShell';

declare global {
  interface Window {
    __INITIAL_DATA__?: any;
  }
}

const router = createBrowserRouter(routes);

hydrateRoot(
  document.getElementById('root')!,
  <AppShell router={router} initialData={window.__INITIAL_DATA__} />
);
```

- `entry-server.tsx`：

```tsx
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { createMemoryRouter } from 'react-router-dom';
import { routes } from './routes';
import { AppShell } from './AppShell';

export function render(url: string, initialData: any) {
  const router = createMemoryRouter(routes, {
    initialEntries: [url],
  });

  return ReactDOMServer.renderToString(
    <AppShell router={router} initialData={initialData} />
  );
}
```

2. Vite 配置（先简化：固定 client 入口名）

`apps/web/vite.config.ts` 中：

- 指定 `build.rollupOptions.input` 产出 `assets/entry-client.js`
- 开启 SSR 构建（可以先只让 server 用 ts-node 直接跑，后面再精细化）

第一版可以先只 build client，server bundle 暂时由 ts-node 直接 import 源码（开发阶段）。

3. `apps/server/src/ssr.ts`：实现 SSR 路由

```ts
import Router from '@koa/router';
import type Koa from 'koa';
import { render } from '../../web/src/entry-server'; // 开发阶段：直接用源码

const router = new Router();

function htmlTemplate(appHtml: string, initialData: any) {
  const initialDataJson = JSON.stringify(initialData).replace(/</g, '\\u003c');
  return `<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <title>SSR Blog</title>
  </head>
  <body>
    <div id="root">${appHtml}</div>
    <script>window.__INITIAL_DATA__ = ${initialDataJson};</script>
    <script type="module" src="http://localhost:5173/src/entry-client.tsx"></script>
  </body>
</html>`;
}

router.get('(.*)', async (ctx: Koa.Context) => {
  const url = ctx.path;
  const initialData = {}; // 后面再填数据
  const appHtml = render(url, initialData);
  ctx.type = 'text/html';
  ctx.body = htmlTemplate(appHtml, initialData);
});

export default router;
```

> 注意：开发阶段可以直接指向 Vite dev server 的入口；生产阶段再用 build 输出的 `/assets/xxx.js`。

4. 在 `apps/server/src/index.ts` 中：

- `app.use(serve(clientDistPath))`（生产时）
- `router.use('/api', apiRouter.routes())`
- `router.use(ssrRouter.routes())`

### 阶段效果

- 访问 `http://localhost:3000/` 和 `/about`，能看到 SSR 页面
- 刷新不会 404
- 点击 React Router `<Link>` 能在前端不刷新切换路由（SPA 体验）

---

## 阶段 2：数据库 & Prisma & 基础数据模型

### 目标

- 使用 SQLite + Prisma 建立基础库结构（users、posts、categories、tags）
- 实现数据库连接 & 基本 CRUD（先不暴露 API，只在 service 层验证）

### 关键技术

- Prisma schema 设计
- SQLite provider
- Prisma Client

### 关键模型（初稿）

- `User`：`id, username, passwordHash, role(enum), createdAt`
- `Category`：`id, slug, name`
- `Tag`：`id, slug, name`
- `Post`：
  - `id, title, slug, content, summary, coverImageUrl, authorId, categoryId, publishedAt, createdAt, updatedAt`

- `PostTag`：多对多表（`postId + tagId` 复合主键）
- **（为 RBAC 预留）`UserCategoryPermission`**：
  - `userId, categoryId`
  - 表示该用户对某个类别有编辑权限

> 提前为阶段 6 的 RBAC 预留结构，避免后续大改。

### 具体工作

1. 在根目录安装 Prisma：

```bash
pnpm add -D prisma
pnpm add @prisma/client
npx prisma init --datasource-provider sqlite
```

2. 修改 `prisma/schema.prisma`：定义核心表（简化版）：

- User（id, username, passwordHash, role）
- Category
- Tag
- Post（title, slug, content, summary, authorId, categoryId, createdAt, updatedAt）
- PostTag（多对多）

3. `npx prisma migrate dev` → 生成 SQLite 文件

4. 在 `apps/server/src/db/prisma.ts`：

```ts
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();
```

5. 在 `apps/server/src/services/post.service.ts` 编写：

- `listPublishedPosts`
- `getPostById`
- `createPost`
- `updatePost`
- `deletePost`

先写简单逻辑，只在一个测试脚本里调用验证。

### 阶段效果

- 你能在 Node 脚本中使用 `postService.listPublishedPosts()` 得到数据
- 有一个实际 SQLite 文件在项目中存储博客数据

---

## 阶段 3：后端 API 分层 & 基本接口

### 目标

- 建立标准后端分层：Router → Controller → Service → DB
- 提供简单 JSON API：`/api/posts`、`/api/posts/:id`

### 关键技术

- Koa Router
- Controller / Service 分层
- DTO 放到 `/packages/shared`

### 约束规范

- `controllers`：
  - 命名：`xxx.api.controller.ts`
  - 不写业务逻辑，只做参数解析、调用 service、返回 DTO

- `services`：
  - 实现业务逻辑，可以调用多个 repository/外部服务

- `repositories`（可选）：
  - 仅负责 Prisma 调用（纯 CRUD）

- `routes/api.ts`：组合各模块路由，挂到 `/api`

### 具体工作

1. `packages/shared` 中定义 DTO 类型：

```ts
// packages/shared/src/post.dto.ts
export interface PostSummaryDto {
  id: number;
  title: string;
  summary: string;
  createdAt: string;
  // ...
}
export interface PostDetailDto extends PostSummaryDto {
  content: string;
}
```

2. `apps/server` 使用这些 DTO：
   - controller 中把 Prisma 返回的 model 转成 DTO

3. `apps/server/src/controllers/post.api.controller.ts`：

```ts
import { postService } from '../services/post.service';

export async function listPosts(ctx: Koa.Context) {
  const posts = await postService.listPublished();
  ctx.body = posts; // 先直接透传 DTO
}

export async function getPost(ctx: Koa.Context) {
  const id = Number(ctx.params.id);
  const post = await postService.getById(id);
  if (!post) {
    ctx.status = 404;
    ctx.body = { message: 'Not Found' };
    return;
  }
  ctx.body = post;
}
```

4. `apps/server/src/routes/api.ts` 挂载：

```ts
router.get('/posts', postApiController.listPosts);
router.get('/posts/:id', postApiController.getPost);
```

5. Koa 入口将 `/api` 路由挂上。

### 阶段效果

- `GET /api/posts` 返回 JSON 列表
- `GET /api/posts/:id` 返回 JSON 详情

---

## 阶段 4：前台页面骨架（React 部分，先不管 SSR 数据）

### 目标

- 基于 shadcn/ui + tailwindcss 搭建前台 UI
- 搭出前台 Layout，尽量贴近现有博客 UI
- 在前端 `apps/web` 中搭出页面结构：
  - 首页：列表（假数据）
  - 详情页：显示一篇文章（假数据）
  - 分类 / 标签页：基本结构占位
  - 错误页（404 / 500）

- 参考目前的博客 UI，尽量贴近
  - 示意图在 `docs/images` 目录下
  - 可进一步参考 `docs/hugo 主题参考/hugo-theme-stack` 目录下的 Hugo 主题

- 在这一阶段可以开始顺手用一些 React 19 的“现代 Hooks”：
  - useId：用在表单控件、可复用 UI 组件里保证 SSR/CSR DOM id 一致；
  - useTransition：如果有比较重的切换动画可以考虑；（优先级低）
  - 但这些只是建议，核心还是把布局搭起来。

### 布局规范（UI 设计约束）

**主页整体布局：三栏结构，类似你图里的 Hugo 博客主题：**

```txt
------------------------------------------------------
|   aside-left   |            main           | aside-right |
------------------------------------------------------
```

对于详情页、分类/标签页，布局为：

```txt
------------------------------------------------------
|   aside-left   |            main                    |
------------------------------------------------------
```

对于错误页，布局为：

```txt
------------------------------------------------------
|            main                    |
------------------------------------------------------
```

#### 1. 整体

[示例图](images/image-项目规划.png)

- 有页面背景（透明遮罩），以下仅供参考：

```html
<div
  class="background"
  id="background"
  style='background-image: url("/img/background_01.jpg");'
>
  <script>
    let backgroundElem = document.getElementById('background'),
      backgroundList = [
        {
          illustrator: 'のう',
          local: true,
          pixivID: 84038692,
          src: 'img/background_01.jpg',
        },
        {
          illustrator: 'のう',
          local: true,
          pixivID: 84150375,
          src: 'img/background_02.jpg',
        },
        {
          illustrator: 'のう',
          local: true,
          pixivID: 83166664,
          src: 'img/background_03.jpg',
        },
      ];
    _length = backgroundList.length;

    let rand = Math.floor(Math.random() * _length);
    while (backgroundList[rand].appear == false)
      rand = Math.floor(Math.random() * _length);
    let background = backgroundList[rand];

    if (sessionStorage.getItem('background'))
      backgroundElem.style.backgroundImage =
        sessionStorage.getItem('background');
    else {
      let url;
      if (background.local) url = 'url(/' + background.src + ')';
      else url = 'url(/' + background.src + ')';
      backgroundElem.style.backgroundImage = url;
      sessionStorage.setItem('background', url);
    }
  </script>
</div>

.background { opacity: .3; background-repeat: no-repeat; background-position:
50%; background-size: cover; background-attachment: fixed; position: fixed;
height: 100%; width: 100%; min-height: 420px; z-index: -1; }
```

#### 2. 左侧 aside-left（固定宽度）

- 主要内容：
  - 头像 + 名称（站长信息）
  - 简短签名（例如“万华收尽……”）
  - 主导航（主页 / 关于 / 归档 / 搜索）
  - 底部：主题切换开关（明暗模式）

对应 React 结构建议：

- `layouts/SiteLayout.tsx` 中抽出组件：
  - `<SiteSidebar />`：包含头像、导航、主题切换

- 该侧栏在首页与详情页**复用**。

#### 3. 中间 main（内容卡片）

- **首页**：
  - 卡片列表，每个卡片包含：
    - 封面图（大图占上半部分）
    - 标签 Badge（如“测试”“随笔”等）
    - 标题（可 hover 放大/变色）
    - 摘要（前几行文字）
    - 元信息：发布日期、阅读时长、阅读量等（图中是浅灰文字 + 图标）

  - 卡片之间有大间隔，整体类似“左右留白 + 中间居中卡片流”。

- **详情页**：
  - 顶部大封面图（宽幅 Banner）
  - 标题、标签、元信息
  - 内容区：
    - Markdown 渲染文章内容
    - 代码块高亮（后续阶段再做）

  - ToC：**不固定在右栏，而是一个悬浮按钮 + Popover 展示目录**：
    - 右下 / 中右位置悬浮圆形按钮
    - 点击打开 Popover，内容为文章各标题的列表

- **404 页**：
  - 保持相同 Layout（左侧导航 + 背景）
  - main 中显示一个“404 错误 / 页面不存在”的卡片（如你图一）

#### 4. 右侧 aside-right（辅助信息）

**仅主页才有**。

- 搜索框（输入关键字）
- 归档（按年份统计）
- 标签云（tag chips，点击跳转到 `/tags/:slug`）
- 友情链接（可后期填）

### React 组件组织建议

- `layouts/SiteLayout.tsx`
  - `<SiteSidebar />`
  - `<SiteMain />`（承载 `<Outlet />`）
  - `<SiteRightAside />`

- `pages/blog/HomePage.tsx`：首页

- `pages/blog/PostDetailPage.tsx`：详情

- `pages/blog/CategoryPage.tsx`：分类页

- `pages/blog/TagPage.tsx`：标签页

- `pages/boundary/NotFoundPage.tsx`：404

### 关键技术

- React Router 7 嵌套路由（createBrowserRouter + children 配置）
- shadcn/ui + Tailwind 基本布局
- 组件拆分（Layout / Page / Components）

### 具体工作

1. 把 `routes.tsx` 改成：

```tsx
export const routes = [
  {
    path: '/',
    element: <SiteLayout />, // 左侧导航 + 顶部栏
    children: [
      { index: true, element: <HomePage /> },
      { path: 'posts/:id', element: <PostDetailPage /> },
      { path: 'tags/:tag', element: <TagPage /> },
      { path: 'about', element: <AboutPage /> },
    ],
  },
  {
    path: '/admin',
    element: <AdminLayout />,
    children: [
      { index: true, element: <AdminDashboardPage /> },
      { path: 'posts', element: <AdminPostListPage /> },
      { path: 'posts/new', element: <AdminPostEditPage /> },
      { path: 'posts/:id', element: <AdminPostEditPage /> },
      { path: 'users', element: <AdminUserListPage /> },
    ],
  },
];
```

2. 用 shadcn/ui + Tailwind 做出Component, Layout, Pages。

3. 此阶段数据可以用 `mock` 常量数组，先不连 API，不要分心。

4. 定义一个通用 ErrorBoundary：

```tsx
// components/common/ErrorBoundary.tsx
class ErrorBoundary extends React.Component<Props, State> { ... }
```

5. 在 `AppShell` 里包裹 `<RouterProvider>`：

```tsx
<AppShell>
  <ErrorBoundary>
    <RouterProvider router={router} />
  </ErrorBoundary>
</AppShell>
```

6. 404 页面由 React Router 的 `path: '*'` route 提供；网络错误/渲染异常由 ErrorBoundary 兜底。

### 阶段效果

- 前端 SPA 路由结构完整，页面跳转不刷新
- SSR 仍然只渲染“壳 + 路由”，无真实数据
- UI 布局已经有明显“已有博客风格”
- 任意路由异常渲染不会把整个应用打崩，而是显示错误页

---

## 阶段 5：SSR + React Router 7 Data Router + React 19 数据预取全链路打通（核心阶段）

### 5.1 基础方案

#### 目标

- SSR 时，服务器根据 URL 预取数据（posts / post detail）并传给 React
- 前端首屏渲染用的是服务器数据，而非浏览器 fetch
- 保持 SPA 体验

#### 关键技术

- `fetchDataForUrl(url)` 服务端实现
- SSR 渲染 `render(url, initialData)`
- 客户端通过 `window.__INITIAL_DATA__` hydrate

#### 约束规范

- `fetchDataForUrl` 放在 `server/services/ssr-data.service.ts` 之类位置，不与业务 service 混在一起
- Home / Detail / Category / Tag 四个页面都可以在 SSR 阶段预取数据（后面阶段 8 会扩展）

#### 具体工作

1. `apps/server/src/fetchDataForUrl.ts`：

```ts
export async function fetchDataForUrl(url: string) {
  if (url === '/') {
    const posts = await postService.listPublished();
    return { posts };
  }
  const matchPost = url.match(/^\/posts\/(\d+)/);
  if (matchPost) {
    const id = Number(matchPost[1]);
    const post = await postService.getById(id);
    return { post };
  }
  return {};
}
```

2. SSR 路由中调用：

```ts
router.get('(.*)', async (ctx) => {
  const url = ctx.path;
  const initialData = await fetchDataForUrl(url);
  const appHtml = render(url, initialData);
  ctx.body = htmlTemplate(appHtml, initialData);
});
```

3. 前端页面通过 `InitialDataContext` 获取数据：

```tsx
const initialData = useContext(InitialDataContext);

export function HomePage() {
  const posts = initialData?.posts ?? [];
  // ...
}
```

#### 阶段效果

- 首次访问 `/` / `/posts/:id` 时，页面是完整 SSR 的
- 页面 HTML 中包含渲染好的内容 + 初始数据脚本
- 首屏无需额外 fetch 即可显示内容

### 5.2 升级方案：React Router 7 Data Router + React 19 use() / useLoaderData()（推荐）

在基础方案跑通之后，你可以把“SSR 数据预取”升级为“**路由驱动的数据流**”，顺便用上 React 19 的 `use()` + Suspense。

#### 思想对比

- 基础版：
  - 服务端：根据 URL 手写 `fetchDataForUrl`
  - 前端：通过 `InitialDataContext` 自己读

- 升级版：
  - **数据定义 → 放到 React Router 7 的 `loader` 上**
  - **服务端 → 调用 React Router 的 `createStaticHandler` 执行 loader**
  - **前端 → 用 `useLoaderData()` 或 `use()` 来消费数据（可配合 `<Suspense fallback>`）**
  - 数据注水由 React Router 自己的协议完成（你只要在 SSR 模板中插入它生成的 JSON）

#### 升级步骤（简略版）

1. **在路由配置中为每个页面定义 loader**

```tsx
// apps/web/src/routes/index.tsx
import { defer } from 'react-router-dom';
import { getPostList, getPostDetail } from '../services/post';

export const routes = [
  {
    path: '/',
    element: <SiteLayout />,
    children: [
      {
        index: true,
        loader: async () => {
          // 可以直接 return 数据，也可以 return Promise / defer
          const posts = await getPostList();
          return { posts };
        },
        element: <HomePage />,
      },
      {
        path: 'posts/:id',
        loader: async ({ params }) => {
          const postPromise = getPostDetail(params.id!); // 返回 Promise
          // 这里可以用 React 19 的 `use()` 读它，所以直接传 Promise 也可以
          return { postPromise };
        },
        element: <PostDetailPage />,
      },
    ],
  },
];
```

2. **服务器端不再手写 `fetchDataForUrl`，改用 React Router 7 的 Static Handler**

概念结构类似：

```ts
// apps/server/src/routes/ssr.ts（伪代码结构示意）
import {
  createStaticHandler,
  createStaticRouter,
  StaticHandlerContext,
} from 'react-router-dom/server';
import { routes } from '../../web/src/routes';

const handler = createStaticHandler(routes);

router.get('(.*)', async (ctx) => {
  const request = new Request(`http://ssr-blog${ctx.url}`, {
    method: ctx.method,
    headers: ctx.headers,
  });

  const context: StaticHandlerContext = await handler.query(request);
  const router = createStaticRouter(handler.dataRoutes, context);

  const { pipe } = ReactDOMServer.renderToPipeableStream(
    <RouterProvider router={router} />,
    {
      onShellReady() {
        // 这里写入 HTML 头部
        pipe(ctx.res);
      },
    }
  );

  // dataRoutes/context 里包含了所有 loader 的结果，
  // React Router 会负责在 HTML 中生成一段 hydration data（注水 JSON）。
});
```

> 这一步的 API 细节我们后面写代码时再精讲，你现在只需要知道：
> **“服务端执行 loader → React Router 拿到 loader 结果 → 生成 HTML + loader 数据注水 JSON”，你不再手写 `fetchDataForUrl` 和 `window.__INITIAL_DATA__`。**

3. **页面组件中使用 `useLoaderData()` 或 `use()` 读取数据**

- 如果 loader 直接返回数据：

```tsx
import { useLoaderData } from 'react-router-dom';

export function HomePage() {
  const { posts } = useLoaderData() as { posts: PostSummaryDto[] };
  // SSR + CSR 都能拿到同一份数据
}
```

- 如果 loader 返回 Promise + React 19 `use()` + Suspense：

```tsx
import { use } from 'react';
import { useLoaderData } from 'react-router-dom';

export function PostDetailPage() {
  const { postPromise } = useLoaderData() as { postPromise: Promise<PostDto> };
  const post = use(postPromise); // Promise 未完成时，会挂起到最近的 <Suspense>

  return (
    <article>
      <h1>{post.title}</h1>
      {/* ... */}
    </article>
  );
}

// Router 外层需要有 Suspense：
function AppShellWithSuspense({ router }: { router: Router }) {
  return (
    <React.Suspense fallback={<div>加载中...</div>}>
      <RouterProvider router={router} />
    </React.Suspense>
  );
}
```

4. **React 19 + Suspense 的价值**

- SSR 时：
  - loader 在服务端执行，Promise 通常已经 resolved，`use(postPromise)` 直接拿数据，不触发 fallback；

- CSR 导航时：
  - loader 在客户端跑，`use()` 会在 Promise pending 期间展示 `<Suspense fallback>`，体验优雅；

- 不再维护“并行的 fetchDataForUrl 和 useContext 逻辑”，而是把“数据需求”集中到路由层。

---

## 阶段 6：后台登录 & JWT 鉴权 & 权限模型

### 目标

- 实现登录接口 `/api/auth/login`
- 后台管理相关 API 受 JWT 保护
- 后端有角色字段（admin / editor） + 类别粒度权限（RBAC）
- 前端后台登录页 & token 存储（localStorage）

### 关键技术

- `koa-jwt`
- `jsonwebtoken`
- 中间件 `requireRole` 实现 RBAC

### 角色定义

两个个角色：

1. **ADMIN（管理员）**
   - 管理用户（增删改查）
   - 管理所有文章（所有类别）
   - 管理类别 / 标签

2. **EDITOR（普通编辑）**
   - 仅能增删改查**自己有权限的类别**下的文章
   - 不能管理用户
   - 不能创建/删除类别
   - 不能更改别人文章的作者

### 权限模型实现方式

- `User.role`: enum(ADMIN, EDITOR)
- `UserCategoryPermission` 表：
  - `userId, categoryId`
  - 对于 `ADMIN` 可以不查该表，直接拥有所有类别权限
  - 对于 `EDITOR`，只允许操作 `UserCategoryPermission` 内记录的类别

### 具体工作（略写要点）

1. Prisma 中 User 表增加 `role` 字段（enum: ADMIN/EDITOR/USER）。
2. 实现 `/api/auth/login`：
   - 校验用户名/密码
   - 成功则 `jwt.sign({ userId, role }, JWT_SECRET, { expiresIn: '2h' })`

3. `koa-jwt` 全局中间件保护 `/api/admin/*` 路由。
4. `requireRole('admin')` 中间件在敏感路由使用。
5. 前端后台管理登录页：
   - 提交到 `/api/auth/login`
   - token 存在 localStorage 或 cookie
   - 请求 `/api/admin/*` 时在 header 带 `Authorization: Bearer xxx`

### 后端中间件

1. **认证中间件：`koa-jwt`**

- 挂在 `/api/admin` 前面
- 校验 token，有效时把 payload 放入 `ctx.state.user`

2. **角色中间件：`requireRole(...roles)`**

- 检查 `ctx.state.user.role` 是否在允许名单中
- 否则返回 `403 Forbidden`

3. **类别粒度权限中间件：`requireCategoryPermission`**

- 在创建/修改文章时，检查用户是否对该 categoryId 有权限：
  - 如果是 ADMIN，直接通过
  - 如果是 EDITOR：查询 `UserCategoryPermission` 中是否存在 `userId + categoryId`

**例子：**

```ts
router.post(
  '/api/admin/posts',
  requireRole('ADMIN', 'EDITOR'),
  requireCategoryPermission('body.categoryId'),
  postController.create
);
```

这里 `requireCategoryPermission('body.categoryId')` 表示从请求 body 中拿 `categoryId` 来检查权限。

### 阶段效果

- 登录后能进入后台界面
- 未登录不带 token 访问 /admin 或相关 API `/api/admin/*` → 401/403
- 带普通编辑 token 编辑不属于自己类别的文章 → 403
- 管理员操作所有文章、所有用户 → OK

---

## 阶段 7：后台文章管理 + Markdown 编辑器

### 目标

- 后台文章列表 / 新建 / 编辑 / 删除
- 编辑页使用 `@uiw/react-md-editor` 快速实现 Markdown 编辑
- 保存时把 markdown 存入 DB

### 关键技术

- React 表单 + Markdown 编辑器
- 调用后端 API
- SSR 对后台可以先不做（不需要 SEO 等 SSR 优点，admin 完全 CSR 也可以）

### 规范约束

- 后台页面目录放在 `pages/admin/*`
- Layout 独立：`layouts/AdminLayout.tsx`（左侧菜单 + 顶部工具栏）
- 先用 `@uiw/react-md-editor`，后续可以在此文件内部替换为 Milkdown 实现，不影响外层业务逻辑

### 具体工作

1. `AdminPostListPage`：
   - 调 `/api/admin/posts` 获取列表
   - 表格展示 + “编辑”/“删除”按钮

2. `AdminPostEditPage`：
   - 通过路由 param 判断是新建还是编辑
   - 用 `MDEditor value={content} onChange={setContent}` 实现编辑
   - 保存按钮调用 `/api/admin/posts`（POST/PUT）

3. SSR 对 `/admin` 路由可以直接返回一个“只用 CSR 渲染的壳”，先别管 SSR，优先功能。

### 阶段效果

- 能通过后台创建/编辑文章
- 前台 `/` 和 `/posts/:id` 能看到这些文章

---

## 阶段 8：分类标签页 / 前台体验完善

### 目标

- 用 markdown-it + sanitize-html 渲染 markdown 文章内容
- 实现真正的分类页、标签页（类似你博客的 `/categories/XXX/`、`/tags/XXX/`）
- 支持 SSR + CSR 跳转
- 补充分页、搜索等体验
- 主题切换（shadcn/ui 提供的 Theme 切换）

### 关键技术

- markdown-it 渲染 & XSS 安全
- URL query / params 筛选
- 前端分页 UI

### 路由设计

- `/categories/:slug` → CategoryPage
- `/tags/:slug` → TagPage

对应后端：

- `fetchDataForUrl('/categories/:slug')`：
  - 根据 slug 找到 Category
  - 查询该类别下所有已发布文章（可分页）

- `fetchDataForUrl('/tags/:slug')`：
  - 根据 slug 找到 Tag
  - 查询该标签关联的所有文章

前端：

- 在首页的文章卡片上展示 tag chips，点击跳转到 `/tags/:slug`
- 右侧 aside 的分类列表点击跳到 `/categories/:slug`

### 语义说明（按你的要求）：

- **分类页**（Category）：
  - 1 对多，一个类别下多个文章
  - 类似：`https://blog.supersassw.com/categories/游戏/`
  - 页面展示：类别名称 + description + 该类别下文章列表卡片

- **标签页**（Tag）：
  - 多对多，一个标签可被多个文章使用，一个文章可有多个标签
  - 类似：`https://blog.supersassw.com/tags/ACM/`
  - 页面展示：标签名称 + tag 描述/统计 + 该标签下文章列表卡片

### 具体工作

1. 文章详情页中：

```ts
import MarkdownIt from 'markdown-it';
import sanitizeHtml from 'sanitize-html';

const md = new MarkdownIt();

const html = sanitizeHtml(md.render(post.content), { /* options */ });

<div dangerouslySetInnerHTML={{ __html: html }} />
```

2. 分类 / 标签页：
   - 基于 URL `/tags/:tag` / `/categories/:id`
   - 服务端 `fetchDataForUrl` 按标签/分类取数据

3. 主题切换：
   - 直接使用 shadcn/ui 官方 ThemeProvider 示例
   - 在 Layout 中放切换按钮，基于 localStorage 记住设置

### 阶段效果

- 分类/标签页可从首页跳入，也可直接访问 URL（SSR 支持）
- 刷新不 404，且首屏已经有数据

---

## 阶段 9：安全与工程化完善

### 目标

- 错误处理
- 搭建一套可维护的日志体系，明确“记录什么、不记录什么”，区分开发/生产日志策略
- 跨域配置正确
- 基本限流占位（不必非常复杂）

### 关键技术

- 全局 error handler 中间件
- koa-logger / 自定义日志
- koa-ratelimit（简单配置）

### 日志类别与规范

建议分三层：

1. **访问日志（Access Log）**
   - 每个 HTTP 请求一条
   - 内容：
     - 时间戳
     - 请求方法 & 路径
     - 状态码
     - 响应时间（ms）
     - 客户端 IP
     - userId（如果已登录）

   - 工具：
     - `koa-logger`（开发环境）
     - 生产可换成 pino/winston + 自定义中间件，输出 JSON

2. **应用日志（Application Log）**
   - 级别：`INFO / WARN / ERROR`
   - 记录：
     - 关键业务行为（例如后台删除文章、修改用户角色）
     - 外部服务调用失败（如 DB/Redis 出错）
     - 非预期异常（try/catch 中的 error）

   - 格式（建议 JSON）：
     - `timestamp`
     - `level`
     - `message`
     - `context`: `{ userId, route, params, ... }`

3. **安全日志（Security Log）**
   - 登录失败次数异常
   - 可疑的访问模式（频繁 401/403）
   - 重要账号权限变更

> 规范：
>
> - **不记录敏感信息**：密码明文、完整 JWT、完整请求体（只允许记录必要字段或屏蔽部分）。
> - token 可以记录前几位做排查，但绝不完整日志。
> - 日志写到文件时注意按日期切分（logrotate 或 logger 的 rolling 策略）。

### 实现建议

- 创建 `utils/logger.ts` 封装日志工具（可用 `pino` 或 `winston`）
- 封装：

```ts
logger.info('User created', { userId, operatorId });
logger.error('DB error', { error, query });
```

- 在 `middleware/error-handler.ts` 中捕获未处理异常并 `logger.error` 一条。

### 具体工作

1. 最前面加一个 error handler：

```ts
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err: any) {
    ctx.status = err.status || 500;
    ctx.body = { message: err.message || 'Internal Server Error' };
    console.error(err);
  }
});
```

2. 配置 `koa-ratelimit` 针对 `/api`：

- 用内存 store（足够了）
- 限制 IP 每分钟请求数等

3. 检查所有 markdown 渲染路径都通过 `sanitize-html`。

### 阶段效果

- 任意后端错误都有日志可查
- 用户管理 / 文章管理等关键操作在日志中有记录
- 日志格式统一、可用脚本分析

---

## 阶段 10：可选进阶（有时间再做）

- 把 SQLite 换成 MySQL（修改 Prisma datasource + migrate）
- Milkdown 替换 `react-md-editor`：
  - 只在客户端渲染编辑器（useEffect 中延迟加载）

- 评论系统：
  - 简单：utterances
  - 复杂：GitHub OAuth + 自建 comment 表

- 导出功能：
  - 调用后端 API，用 markdown → PDF 或生成 MD 文件下载

- Redis 缓存：
  - 缓存热门文章列表
  - 简单 HTTP 缓存（ETag / Last-Modified）

- 代码分割：
  - 路由级别 lazy import（React.lazy + Suspense）
