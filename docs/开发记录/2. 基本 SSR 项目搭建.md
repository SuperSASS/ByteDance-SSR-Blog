# 0x02 基本 SSR 项目搭建

## 1. 最小 SSR 项目

为了跑通 SSR 以理解流程，这里搭建一个最小 SSR 项目。

- 前端`apps/web`
  - `src/entry-client.tsx`：客户端入口
  - `src/entry-server.tsx`：服务端入口
  - `src/app/AppShell.tsx`：应用壳
  - `src/routes/routes.tsx`：路由配置
- 后端`apps/server`
  - `src/app.ts`：Koa 入口
  - `src/routes/ssr.ts`：SSR 路由（页面路由）

参照着[开发阶段安排](../开发阶段安排.md)的阶段1，完成 SSR 项目的基本框架搭建。

**问题记录**：

1. 前后端 import 的问题
   目前设计中，server 都是直接`import`前端的 React 组件和路由。  
   在这里就因为`ssr.ts`路由直接`import routes from '../../web/src/routes/routes';`，导致裸 Node + tsx无法找 React 报错。  
   为了尽快调通，这里直接在`routes.tsx`中`import React from 'react';`临时解决。

   同时为了避免 build 时导致的 TS lint 问题等，这里让 gpt 改为动态加载，避免 build 时的问题。

2. `pnpm run dev`后，访问后端页面，出现`error: Error: No route matches URL "/favicon.ico"`  
   这是因为还会发起`GET /favicon.ico`请求，但目前也匹配到 SSR 页面路由上了，导致出错，  
   这里暂时忽略，日后增加静态资源中间件。

---

### 生产与部署的不同

在生产（build 部署）环境下，只需要**启动后端服务器**，然后**通过后端服务器地址（`:3000`）访问**。

而在开发环境下，由于前端没有 build，后端又有地方直接依赖前端的 build 输出，  
故需要同时`run dev`前端开发服务器和后端开发服务器，让前端开发服务器提供输出并实时反映到后端（支持 HMR 热更新）。

说明：现在`web`当中的`index.html`没有用了，因为并不会从前端服务中访问网站。  
但好像可以留着以后降级 CSR 有用。

同时，现在`pnpm run build`会有问题：因为为了解决server的`ssr.ts`在引入web的`routes.tsx`没有 React 的问题，在`routes.tsx`中加了`import React from 'react';`，  
又因为`web`的`tsconfig.app.json`中配置了`"noUnusedLocals": true,`，构造会报错：'React' is declared but its value is never read。  
现在暂不解决，以后可以改为 false。

---

### SSR SPA 的基本流程

这里从路由的角度解释下 **SSR SPA 的基本流程**：

1. 用户通过 URL 进入某页面`www.example.com/post/1`（这里以一个特定页面而非主页为例，更通用）  
   此时浏览器会向后端服务器（如果是 dev 模式则是`localhost:3000`）发送请求`GET /post/1`
2. 后端服务器接收到请求后，会因为`ssr.ts`中有通配监听`/(.*)/`，故进行处理  
   其中调用了来自`entry-server.tsx`的`render`函数。  
   ![步骤2](<images/image-2. 最小SSR项目搭建.png>)
3. `render`函数中，会根据`routes.ts`中定义的 routes 以及现在的`url`，创建**后端的 router（目前是`createMemoryRouter`）**，用于传入`AppShell`进行路由匹配（`RouterProvider`）并替换成对应的 layout, page。  
   最后调用关键函数`ReactDOMServer.renderToString()`，将 App （内部包含基于 router 匹配到的 layout, page）渲染成 HTML 字符串，返回。
   ![步骤2](<images/image-2. 最小SSR项目搭建-1.png>)
4. `ssr.ts`接收到返回的`appHtml`，则与模板拼装，然后返回给浏览器。  
   可以在浏览器里看到 SSR 页面。  
   ![步骤3](<images/image-2. 最小SSR项目搭建-2.png>)  
   可见`root`中并不为空
5. 接下来根据`<script type="module" src="http://localhost:5173/src/entry-client.tsx"></script>`，加载`entry-client.tsx`脚本，进行水合，在其中调用`hydrateRoot`，从而挂上事件等东西。  
   比如像 React Router 的逻辑就在此时挂在，从而使得`<Link>`起作用，**变成 SPA**。
   ![步骤4](<images/image-2. 最小SSR项目搭建-3.png>)  
   有两个要点：
   - 要保证`hydrateRoot()`调用时，第二个参数`initialChildren`跟服务器返回的一致（客户端 React 渲染出来的虚拟 DOM 要和 服务端已经生成的真实 DOM 在结构/属性上匹配），这样才能匹配上进行水合  
     故可见`entry-client.tsx`, `entry-server.tsx`都用了同一个`<AppShell>`，并用了几乎相同的`router`和`initialData`
   - `initialData`的作用是：防止重复请求数据。  
     此时前端 React 框架接管页面，其中可能存在像`loader/useEffect`这样的数据获取逻辑，即便 SSR 返回的是渲染好数据的页面，但这些逻辑并不知道已有数据，会重新向后端请求一遍数据，出现“SSR 页面 -> 空一帧渲染 -> 重新获取数据后的页面”。  
     故这就是`initialData`的作用：后端将数据“注水”到页面中，后续 React 从中“吸水”，从而进行判断，如果有则不再发请求，避免重复请求。

## 2. 数据库设计开发

本项目利用 Prisma 进行数据库设计开发。

### 1. 安装

在根目录安装：

```bash
pnpm add -D prisma
npx prisma init --datasource-provider sqlite
```

_注：这样安装的是 Prisma 7，与 Prisma 6 有破坏性变更。_

### 2. 定义数据模型

然后在`prisma/schema.prisma`定义数据模型：

- 用户：包含角色 enum
- 类别
- 标签
- 文章
- 文章标签关系表

注意：Prisma 7 中，改变有：

1. 不在 generator client 中指定 url 表示 db 文件生成路径，而是要单独写一个`prisma.config.ts`
2. 不在使用`import { PrismaClient } from '@prisma/client';`导入 Client，而是要用 Prisma 生成，需要在 generator client 中写一个 output 指定生成路径

### 3. 编写 Prisma 客户端

在`server/db/prisma.ts`，用以下方式编写：

```ts
import 'dotenv/config';
import { PrismaClient } from './generated/client/client.js';
import { PrismaNodeSQLite } from 'prisma-adapter-node-sqlite';

const url = process.env.DATABASE_URL ?? 'file:../../dev.db';

const adapter = new PrismaNodeSQLite({
  url,
});

export const prisma = new PrismaClient({ adapter });
```

Prisma 7 中，还需要自行指定数据库驱动（adapter），  
在这里用的是`prisma-adapter-node-sqlite`（原本用的`better-sqlite3`，但会出错，所以改成这个）。

### 4. 编写测试（初始化）脚本

在`scripts/seed-db.ts`中编写 DB 重置、添加初始数据、测试的命令，  
以后可以执行该脚本（`"db:reset": "tsx src/scripts/seed-db.ts"`）以重置 DB。

测试结果：  
![测试结果](<images/image-2. 最小SSR项目搭建-4.png>)

## 3. API 开发

对五个数据模型，分别开发 API。

- post
- user
- category
- tag
- userCategoryPermission

按照`DTO`、`Service`、`Controller`、`API`四个层级依次开发。

- DTO：数据传输对象，前后端交互的数据模型（但 SSR 中可能用不到），或说 API 返回数据的模型
- Service：业务逻辑层，调用 DB Client 实现 CRUD
- Controller：控制器，处理 API 请求，调用 Service 实现 CRUD
- API：API 接口，定义路由，调用 Controller
