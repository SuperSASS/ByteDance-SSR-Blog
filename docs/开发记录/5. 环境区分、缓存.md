# 环境区分、缓存

对环境进行进一步规范和明确。

- `pnpm dev`：开发环境
- `pnpm start`：生产环境（本地）
- `pnpm build`：生产环境（部署）

## 开发环境

当使用`pnpm dev`时，此时不存在构建后的产物，都是源码，Vite 会做很多工作：

- 代码编译，使得在浏览器中可用
- **静态文件提供**（即编译后的 js css 产物）
- HMR

需要在 Koa 中使用 viteServer 客户端，详见[官方文档](https://vitejs.cn/vite3-cn/guide/ssr.html)。

首先在`app.ts`中，用`vite.createServer`创建一个 viteServer 客户端，然后挂载到 context 中供其它地方使用，然后加入中间件（注：官方文档用的`app.use(vite.middlewares)`对 Koa 不适用，这里要用`app.use(koaConnect(viteServer.middlewares));`）。

然后在`ssr.ts`中：

1. **`render`函数获取**：对于开发环境（存在 ViteServer），用`ctx.state.vite.ssrLoadModule('/src/entry-server.tsx')`的`render`函数。  
   ![1](<images/image-5. 开发生产环境.png>)
2. **`render`函数调用**，生成 appHtml  
   其中也可能是重定向等相应，此时`type = response`
3. **`html`生成**：
   先用`htmlTamplate`生成基础 HTML（不包含客户端脚本和 CSS），  
   然后再用`ctx.state.vite.transformIndexHtml(ctx.url, html)`注入客户端脚本  
   （此时存在 FOUC 问题，因为 CSS 还没有注入）
4. **设置 ETag 协商缓存**：对于 HTML（动态内容，可用 ETag 来进行“协商缓存”

   > 协商缓存，则是判断之前生成的内容与现在的内容是否有变化：
   >
   > - 如果没有，则只返回一个 304 状态，不返回内容，**优点：减少重复数据传输、节省流量、降低客户端渲染压力**
   > - 如果有，则返回新生成的页面
   >
   > 因此需要能基于内容比较页面是否变化，这里则为每个页面根据内容生成 ETag（Entity Tag，实体 ID），用于比较和标识。  
   > 同时带上'Cache-Control: no-cache'。让浏览器每次都询问服务器内容是否变化，而不是直接使用缓存。（这样才适用于动态内容）
   > ![与 Last-Modified 的区别](<images/image-5. 开发生产环境-1.png>)
   - 服务器端生成 ETag（实体 ID，唯一标识一个 HTML 页面，这里用`crypto.createHash('md5')`生成）
   - 客户端请求时，带上 If-None-Match
   - 服务器端比对 ETag，如果一致，则证明内容未变，返回 304 Not Modified；如果不一致，则返回

   注：Koa 实际上提供了协商缓存中间件（返回带上ETag的`koa-etag`、解析请求If-None-Match的`koa-conditional-get`），但这里手动实现。

## 生产环境

对于生产环境，没有 Vite，只有 build 好的构建产物（js/css/html/资源）。  
因此需要用`koa-static`提供静态资源服务（对应开发环境下 Vite 提供的静态资源服务）。

在`!isDev`下，直接用：

```ts
// 托管 web/dist/client (构建产物)，策略根据文件类型决定
app.use(
  serve(path.join(__dirname, '../../web/dist/client'), {
    index: false, // 不自动 serve index.html，交给 SSR 处理
  })
);
```

_目前这里路径写成这样，到后续部署阶段可能要调整。_

在`ssr.ts`中，也要修改对应的逻辑：

1. `render`函数获取：只能用`import('../../../web/dist/server/entry-server.js')`获取 build 后的 entry-server.js（_路径在部署中可能也要改_）
2. **`render`函数调用**：同上
3. **`html`生成**：关键变动，因为没有 Vite 来注入客户端脚本（entry-client），名字也会带上 hash，所以要用 manifest 来获取构建后的信息，再根据其获得 entry-client.js 的路径并注入。  
   同时为了避免 FOUC，也获取 index.css 的路径并注入。
4. **设置 ETag 协商缓存**：同上

## 静态资源缓存

之前实现了对动态资源（HTML 页面，在`ssr.ts`中）的缓存，  
然后实现静态资源的缓存。

主要是通过`koa-static`中的`setHeaders`来设置缓存头。  
_不用自带的`maxage`选项，是因为无法精细化控制。_

在代码`getCacheOption.ts`中配置了各种静态资源的缓存策略。

## 上传资源管理与实现

1. 增加上传静态资源的目录。

```ts
// 4. 上传文件目录 (Dev & Prod)
const uploadDir = path.join(__dirname, '../uploads'); // 指向 apps/server/uploads
app.use(mount('/uploads', serve(uploadDir, { setHeaders })));
```
