# 环境区分、缓存

对环境进行进一步规范和明确。

- `pnpm dev`：开发环境
- `pnpm start`：生产环境（本地）
- `pnpm build`：生产环境（部署）

## 开发环境

当使用`pnpm dev`时，此时不存在构建后的产物，都是源码，Vite 会做很多工作：

- 代码编译，使得在浏览器中可用
- **静态文件提供**（即编译后的 js css 产物）
- HMR

需要在 Koa 中使用 viteServer 客户端，详见[官方文档](https://vitejs.cn/vite3-cn/guide/ssr.html)。

首先在`app.ts`中，用`vite.createServer`创建一个 viteServer 客户端，然后挂载到 context 中供其它地方使用，然后加入中间件（注：官方文档用的`app.use(vite.middlewares)`对 Koa 不适用，这里要用`app.use(koaConnect(viteServer.middlewares));`）。

然后在`ssr.ts`中：

1. **`render`函数获取**：对于开发环境（存在 ViteServer），用`ctx.state.vite.ssrLoadModule('/src/entry-server.tsx')`的`render`函数。  
   ![1](<images/image-5. 开发生产环境.png>)
2. **`render`函数调用**，生成 appHtml  
   其中也可能是重定向等相应，此时`type = response`
3. **`html`生成**：
   先用`htmlTamplate`生成基础 HTML（不包含客户端脚本和 CSS），  
   然后再用`ctx.state.vite.transformIndexHtml(ctx.url, html)`注入客户端脚本  
   （此时存在 FOUC 问题，因为 CSS 还没有注入）
4. **设置 ETag 协商缓存**：对于 HTML（动态内容，可用 ETag 来进行“协商缓存”

   > 协商缓存，则是判断之前生成的内容与现在的内容是否有变化：
   >
   > - 如果没有，则只返回一个 304 状态，不返回内容，**优点：减少重复数据传输、节省流量、降低客户端渲染压力**
   > - 如果有，则返回新生成的页面
   >
   > 因此需要能基于内容比较页面是否变化，这里则为每个页面根据内容生成 ETag（Entity Tag，实体 ID），用于比较和标识。  
   > 同时带上'Cache-Control: no-cache'。让浏览器每次都询问服务器内容是否变化，而不是直接使用缓存。（这样才适用于动态内容）
   > ![与 Last-Modified 的区别](<images/image-5. 开发生产环境-1.png>)
   - 服务器端生成 ETag（实体 ID，唯一标识一个 HTML 页面，这里用`crypto.createHash('md5')`生成）
   - 客户端请求时，带上 If-None-Match
   - 服务器端比对 ETag，如果一致，则证明内容未变，返回 304 Not Modified；如果不一致，则返回

   注：Koa 实际上提供了协商缓存中间件（返回带上ETag的`koa-etag`、解析请求If-None-Match的`koa-conditional-get`），但这里手动实现。

## 生产环境

对于生产环境，没有 Vite，只有 build 好的构建产物（js/css/html/资源）。  
因此需要用`koa-static`提供静态资源服务（对应开发环境下 Vite 提供的静态资源服务）。

在`!isDev`下，直接用：

```ts
// 托管 web/dist/client (构建产物)，策略根据文件类型决定
app.use(
  serve(path.join(__dirname, '../../web/dist/client'), {
    index: false, // 不自动 serve index.html，交给 SSR 处理
  })
);
```

_目前这里路径写成这样，到后续部署阶段可能要调整。_

在`ssr.ts`中，也要修改对应的逻辑：

1. `render`函数获取：只能用`import('../../../web/dist/server/entry-server.js')`获取 build 后的 entry-server.js（_路径在部署中可能也要改_）
2. **`render`函数调用**：同上
3. **`html`生成**：关键变动，因为没有 Vite 来注入客户端脚本（entry-client），名字也会带上 hash，所以要用 manifest 来获取构建后的信息，再根据其获得 entry-client.js 的路径并注入。  
   同时为了避免 FOUC，也获取 index.css 的路径并注入。
4. **设置 ETag 协商缓存**：同上

## 静态资源缓存

之前实现了对动态资源（HTML 页面，在`ssr.ts`中）的缓存，  
然后实现静态资源的缓存。

主要是通过`koa-static`中的`setHeaders`来设置缓存头。  
_不用自带的`maxage`选项，是因为无法精细化控制。_

在代码`getCacheOption.ts`中配置了各种静态资源的缓存策略。

## 上传资源管理与实现

### 后端

1. 增加上传静态资源的目录`uploads`。

使用`koa-mount`和`koa-static`。

```ts
// 4. 上传文件目录 (Dev & Prod)
const uploadDir = path.join(__dirname, '../uploads'); // 指向 apps/server/uploads
app.use(mount('/uploads', serve(uploadDir, { setHeaders })));
```

其中`mount`只是用来处理前缀的，稍微有些绕（上方的`client` serve 就不用），可以看下面的表格。  
| 想要访问资源的本地目录 | serve定义的目录 | 输入URL后缀 | 实际访问 | 是否需要 mount |
| ------------------------------------------ | ------------------------------ | ----------------- | ---------------------------------------------- | ---------------------------- |
| /SSR-blog/apps/server/uploads/file.jpg | /SSR-blog/apps/server/uploads | /uploads/file.jpg | /SSR-blog/apps/server/uploads/uploads/file.jpg | 需要（去掉 /uploads 前缀） |
| /SSR-blog/apps/web/dist/client/assets/a.js | /SSR-blog/apps/web/dist/client | /assets/a.js | /SSR-blog/apps/web/dist/client/assets/a.js | 不需要（URL 和目录结构一致） |

现在如果在`/uploads`目录下放一个文件，再访问`/uploads/file.jpg`，则可以访问到图片。

2. 使用`koa-multer`处理文件上传。

该中间件专门用来处理文件上传(`multipart/form-data`)的。  
在`upload.middleware.ts`中，进行配置：

```ts
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, path.join(__dirname, '../../uploads')); // 上传目录（在部署时，这个路径可能要修改）
  },
  filename: (_req, file, cb) => {
    const ext = path.extname(file.originalname); // .png\
    const uniqueSuffix = Date.now() + '-' + Math.random().toString(36).slice(2);
    cb(null, uniqueSuffix + ext);
  },
});
// 配置 multer
export const upload = multer({
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
});

export default upload;
```

其中用 storage 详细配置了所上传文件的位置和文件名，limits 则配置了文件大小限制。

当上传文件后，会保存在`uploads`目录下，文件名则根据配置生成（`{uniqueSuffix}{ext}`）。

3. 添加相应的 service、controller、API router。

service 中应判断上传的封面 URL 与之前是否一致（且之前有 URL），如果不一致则删除旧的封面（如果文件不存在则为在线图片，不删除）。

controller 把上传后的文件 URL 返回。

### 前端

- 添加服务对接 API
- 添加图片上传组件`ImageUpload`，可选择在线（URL）或本地上传
- 在`AdminPostEditPage`中使用该组件  
  当上传成功后，通过`setCoverImageUrl`回调函数，将把返回的图片 URL 记录到 state 中。
