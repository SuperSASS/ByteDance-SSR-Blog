# 0x02 最小项目搭建

## 1. 最小 SSR 项目

为了跑通 SSR 以理解流程，这里搭建一个最小 SSR 项目。

- 前端`apps/web`
  - `src/entry-client.tsx`：客户端入口
  - `src/entry-server.tsx`：服务端入口
  - `src/app/AppShell.tsx`：应用壳
  - `src/routes/routes.tsx`：路由配置
- 后端`apps/server`
  - `src/app.ts`：Koa 入口
  - `src/routes/ssr.ts`：SSR 路由（页面路由）

参照着[开发阶段安排](../开发阶段安排.md)的阶段1，完成 SSR 项目的基本框架搭建。

**问题记录**：

1. 前后端 import 的问题
   目前设计中，server 都是直接`import`前端的 React 组件和路由。  
   在这里就因为`ssr.ts`路由直接`import routes from '../../web/src/routes/routes';`，导致裸 Node + tsx无法找 React 报错。  
   为了尽快调通，这里直接在`routes.tsx`中`import React from 'react';`临时解决。

   同时为了避免 build 时导致的 TS lint 问题等，这里让 gpt 改为动态加载，避免 build 时的问题。

2. `pnpm run dev`后，访问后端页面，出现`error: Error: No route matches URL "/favicon.ico"`  
   这是因为还会发起`GET /favicon.ico`请求，但目前也匹配到 SSR 页面路由上了，导致出错，  
   这里暂时忽略，日后增加静态资源中间件。

---

### 生产与部署的不同

在生产（build 部署）环境下，只需要**启动后端服务器**，然后**通过后端服务器地址（`:3000`）访问**。

而在开发环境下，由于前端没有 build，后端又有地方直接依赖前端的 build 输出，  
故需要同时`run dev`前端开发服务器和后端开发服务器，让前端开发服务器提供输出并实时反映到后端（支持 HMR 热更新）。

说明：现在`web`当中的`index.html`没有用了，因为并不会从前端服务中访问网站。  
但好像可以留着以后降级 CSR 有用。

同时，现在`pnpm run build`会有问题：因为为了解决server的`ssr.ts`在引入web的`routes.tsx`没有 React 的问题，在`routes.tsx`中加了`import React from 'react';`，  
又因为`web`的`tsconfig.app.json`中配置了`"noUnusedLocals": true,`，构造会报错：'React' is declared but its value is never read。  
现在暂不解决，以后可以改为 false。

---

### SSR SPA 的基本流程

这里从路由的角度解释下 **SSR SPA 的基本流程**：

1. 用户通过 URL 进入某页面`www.example.com/post/1`（这里以一个特定页面而非主页为例，更通用）  
   此时浏览器会向后端服务器（如果是 dev 模式则是`localhost:3000`）发送请求`GET /post/1`
2. 后端服务器接收到请求后，会因为`ssr.ts`中有通配监听`/(.*)/`，故进行处理  
   其中调用了来自`entry-server.tsx`的`render`函数。  
   ![步骤2](<images/image-2. 最小SSR项目搭建.png>)
3. `render`函数中，会根据`routes.ts`中定义的 routes 以及现在的`url`，创建**后端的 router（目前是`createMemoryRouter`）**，用于传入`AppShell`进行路由匹配（`RouterProvider`）并替换成对应的 layout, page。  
   最后调用关键函数`ReactDOMServer.renderToString()`，将 App （内部包含基于 router 匹配到的 layout, page）渲染成 HTML 字符串，返回。
   ![步骤2](<images/image-2. 最小SSR项目搭建-1.png>)
4. `ssr.ts`接收到返回的`appHtml`，则与模板拼装，然后返回给浏览器。  
   可以在浏览器里看到 SSR 页面。  
   ![步骤3](<images/image-2. 最小SSR项目搭建-2.png>)  
   可见`root`中并不为空
5. 接下来根据`<script type="module" src="http://localhost:5173/src/entry-client.tsx"></script>`，加载`entry-client.tsx`脚本，进行水合，在其中调用`hydrateRoot`，从而挂上事件等东西。  
   比如像 React Router 的逻辑就在此时挂在，从而使得`<Link>`起作用，**变成 SPA**。
   ![步骤4](<images/image-2. 最小SSR项目搭建-3.png>)  
   有两个要点：
   - 要保证`hydrateRoot()`调用时，第二个参数`initialChildren`跟服务器返回的一致（客户端 React 渲染出来的虚拟 DOM 要和 服务端已经生成的真实 DOM 在结构/属性上匹配），这样才能匹配上进行水合  
     故可见`entry-client.tsx`, `entry-server.tsx`都用了同一个`<AppShell>`，并用了几乎相同的`router`和`initialData`
   - `initialData`的作用是：防止重复请求数据。  
     此时前端 React 框架接管页面，其中可能存在像`loader/useEffect`这样的数据获取逻辑，即便 SSR 返回的是渲染好数据的页面，但这些逻辑并不知道已有数据，会重新向后端请求一遍数据，出现“SSR 页面 -> 空一帧渲染 -> 重新获取数据后的页面”。  
     故这就是`initialData`的作用：后端将数据“注水”到页面中，后续 React 从中“吸水”，从而进行判断，如果有则不再发请求，避免重复请求。

## 2. 数据库设计开发
