# 0x03 完整 SSR 项目搭建

## 1. 前台页面实现

实现项目规划中对前台页面各功能的界面和逻辑实现。

在 web 中添加 Tailwind CSS，按照官网的教程来。  
然后让 AI 按照规划编写相应组件、布局、页面等 UI 内容。

---

问题 - 服务端 SSR 时缺少 React 包：

之前是在 web 项目里添加`import React from 'react';`，但这样导致每个 web 项目里会用到 React 的地方都要添加。  
于是现在改为在 server 项目里添加引入：写一个`utils/globalReact.ts`引入 React，然后在入口`app.ts`中`import 'globalReact.js';`。

---

问题 - 运行后完全没有 CSS，控制台报错"@vitejs/plugin-react can't detect preamble. Something is wrong."：

解决方案来自[@vitejs/plugin-react](https://www.npmjs.com/package/@vitejs/plugin-react)，其中的"@vitejs/plugin-react/preamble"写到要在 entry-client.tsx 中添加`import '@vitejs/plugin-react/preamble'`。

---

**问题 - FOUC(Flash Of Unstyled Content)现象**：

FOUC 是指在页面加载时，SSR 渲染的 HTML 不存在样式，而后水合的页面加载样式，导致页面从无样式状态闪烁到有样式状态。

按照原来的写法，SSR 返回的不带样式，样式是在水合的时候加进去的，这样就会导致 FOUC。  
故需要在 SSR 的 template 加上前端的 CSS。

这里采用的方法：通过 vite 的 manifest，读取 CSS 文件位置，然后在 SSR 的 template 的 header 中添加 CSS 标签。

## 2. 数据获取全链路打通

基于 React Router 的数据模式（loader, StaticRouter）实现页面数据从后端 API 预取并消费。

首先需要对路由定义`routes.tsx`添加 loader，如主页：

```tsx
{
  index: true,
  loader: async () => {
    // 主页需要：文章列表、分类列表、标签列表、归档统计
    const [posts, categories, tags, archives] = await Promise.all([
      // 这四个服务都是写在前端的 service 层的，调用后端数据 API。
      postApi.getPublishedPosts(),
      categoryApi.getCategories(),
      tagApi.getTags(),
      postApi.getArchiveStatistics(),
    ]);
    return { posts, categories, tags, archives };
  },
  element: <HomePage />,
},
```

然后分别在前后端的入口`entry-client.tsx`和`entry-server.tsx`进行调整，  
首先调整`<AppShell>`，根据类别选择不同 Router Provider：

```tsx
export function AppShell(props: AppShellProps) {
  return (
    <React.StrictMode>
      <ThemeProvider defaultTheme="system" storageKey="blog-theme">
        {props.type === 'client' ? (
          <RouterProvider router={props.router} />
        ) : (
          <StaticRouterProvider router={props.router} context={props.context} />
        )}
      </ThemeProvider>
    </React.StrictMode>
  );
}
```

`entry-client.tsx`中使用`hydrateRoot`+`RouterProvider`，很简单。

而`entry-server.tsx`中的`render`，变为以下逻辑：

```tsx
export async function render(request: Request) {
  // 1. 创建Static Handler，调用 query() 执行可执行匹配路由项的 loader
  const handler = createStaticHandler(routes);

  // 2. 执行 request 对应路由项的所有loader，获取 context
  // 如果成功，context 则直接是 json 返回结果（在 loader 中 return 的）
  // 如果失败，context 则是 Response 对象
  const context = await handler.query(request);

  // 3. 如果是重定向或错误响应，直接返回
  if (context instanceof Response) {
    return { type: 'response' as const, response: context };
  }

  // 4. 创建Static Router，用于 StaticRouterProvider 选择所需渲染的组件
  const router = createStaticRouter(handler.dataRoutes, context);

  // 5. 渲染React组件为HTML
  const appHtml = ReactDOMServer.renderToString(
    <AppShell type="server" router={router} context={context} />
  );

  return {
    type: 'html' as const,
    html: appHtml,
    context,
  };
}
```

---

此时页面访问流程（以主页为例）：

1. 浏览器输入`www.example.com`，请求 HTML 页面
2. Koa 匹配到 SSR 页面 API（`/(.*)/`），调用`entry-server.tsx`中的`render()`函数
3. `render()`函数中，创建`handler`，根据`request`执行对应的 loader，然后创建 StaticRouter（包含加载的数据），然后`renderToString`渲染`<AppShell>`，根据路由渲染对应 React 组件和数据为 HTML，返回
4. 如果异常进行处理，如果正常则返回渲染的 HTML  
   此时 server 部分结束
5. HTML 中`<script>`脚本加载`entry-client.tsx`，调用`hydrateRoot`进行水合（其中也是`<AppShell>`组件，路由用`RouterProvider`），React 接管页面控制。

此时对于前台（博客页面）的实现已完成，  
接下来将实现后台（管理页面）。
